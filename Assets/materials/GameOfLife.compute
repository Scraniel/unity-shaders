// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
Texture2D<float4> ImageInput;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    //fetch each neighbor texel and current texel.
    //top row
    
    int r00 = round(ImageInput[float2(id.x - 1, id.y - 1)].r);
    int r01 = round(ImageInput[float2(id.x, id.y - 1)].r);
    int r02 = round(ImageInput[float2(id.x + 1, id.y - 1)].r);
 
    //middle row
    int r10 = round(ImageInput[float2(id.x - 1, id.y)].r);
    int r11 = round(ImageInput[id.xy].r);
    int r12 = round(ImageInput[float2(id.x + 1, id.y)].r);
   
    //bottom row
    int r20 = round(ImageInput[float2(id.x - 1, id.y + 1)].r);
    int r21 = round(ImageInput[float2(id.x, id.y + 1)].r);
    int r22 = round(ImageInput[float2(id.x + 1, id.y + 1)].r);
 
    //conways game of life rules:
    //if neighbor count including self is 3, the next generation cell is alive
    //if neighbor count including self is 4, and current cell is alive, the next generation cell is alive
    //otherwise, the next generation cell is dead.
    int finalSum = (r00 + r10 + r20) +
                   (r01 + r11 + r21) +
                   (r02 + r12 + r22);
 

    int val = 1 & ((finalSum & 3) | ((finalSum & 4) & r11));
    
    Result[id.xy] = float4(val,val,val,1);
}
